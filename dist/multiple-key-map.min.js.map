{"version":3,"file":"multiple-key-map.min.js","sources":["../src/index.js"],"sourcesContent":["export default class MultipleKeyMap {\n  store = {};\n  set(keys, value) {\n    let node = this.store\n    for (const key of keys) {\n      if (!node.children) {\n        // 使用WeakMap时出错: Invalid value used as weak map key\n        node.children = new Map\n      }\n      if (!node.children.has(key)) {\n        node.children.set(key, {})\n      }\n      node = node.children.get(key)\n    }\n    node.value = value\n  }\n  getNode(keys) {\n    let node = this.store\n    for (const key of keys) {\n      if (!node.children) {\n        throw [\"can't find by keys\", keys]\n      }\n      node = node.children.get(key)\n    }\n    return node\n  }\n  get(keys) {\n    return this.getNode(keys).value\n  }\n  delete(keys, deleteChildNodes, excludeSelf) {\n    const targetNode = this.getNode(keys)\n    if (!excludeSelf) {\n      delete targetNode.value\n    }\n    if (deleteChildNodes) {\n      delete targetNode.children\n    }\n    // 删除空分支\n    this.autoDeleteEmptyNodes(keys)\n  }\n  autoDeleteEmptyNodes(keys) {\n    const nodes = []\n    let current = this.store\n    let keys2 = keys.slice()\n    while (keys2.length > 0) {\n      const key = keys2.shift()\n      const node = current.children.get(key)\n      nodes.unshift([key, node, current])\n      current = node\n    }\n    for (const [key, node, parent] of nodes) {\n      if (node.children && node.children.size === 0) {\n        delete node.children\n      }\n      if (!node.hasOwnProperty('value') && !node.children) {\n        parent.children.delete(key)\n      } else {\n        break\n      }\n    }\n  }\n  hasNode(keys) {\n    try {\n      return Boolean(this.getNode(keys))\n    } catch (e) {\n      return false\n    }\n  }\n  has(keys) {\n    try {\n      const node = this.getNode(keys)\n      return Boolean(node && node.hasOwnProperty('value'))\n    } catch (e) {\n      return false\n    }\n  }\n}\n"],"names":["keys","value","node","this","store","key","children","Map","has","set","get","getNode","deleteChildNodes","excludeSelf","targetNode","autoDeleteEmptyNodes","nodes","current","keys2","slice","length","shift","unshift","parent","size","hasOwnProperty","delete","Boolean","e"],"mappings":";;;;;qiCAEMA,EAAMC,OACJC,EAAOC,KAAKC,yCACEJ,iDAAM,KAAbK,UACJH,EAAKI,WAERJ,EAAKI,SAAW,IAAIC,KAEjBL,EAAKI,SAASE,IAAIH,IACrBH,EAAKI,SAASG,IAAIJ,MAEpBH,EAAOA,EAAKI,SAASI,IAAIL,sFAE3BH,EAAKD,MAAQA,kCAEPD,OACFE,EAAOC,KAAKC,yCACEJ,iDAAM,KAAbK,cACJH,EAAKI,eACD,qBAAsBN,GAE/BE,EAAOA,EAAKI,SAASI,IAAIL,6FAEpBH,8BAELF,UACKG,KAAKQ,QAAQX,GAAMC,qCAErBD,EAAMY,EAAkBC,OACvBC,EAAaX,KAAKQ,QAAQX,GAC3Ba,UACIC,EAAWb,MAEhBW,UACKE,EAAWR,cAGfS,qBAAqBf,gDAEPA,WACbgB,KACFC,EAAUd,KAAKC,MACfc,EAAQlB,EAAKmB,QACVD,EAAME,OAAS,GAAG,KACjBf,EAAMa,EAAMG,QACZnB,EAAOe,EAAQX,SAASI,IAAIL,GAClCW,EAAMM,SAASjB,EAAKH,EAAMe,IAC1BA,EAAUf,gBAEsBc,aAAO,SAAPA,QAAtBX,OAAKH,OAAMqB,UACjBrB,EAAKI,UAAmC,IAAvBJ,EAAKI,SAASkB,aAC1BtB,EAAKI,SAETJ,EAAKuB,eAAe,UAAavB,EAAKI,eACzCiB,EAAOjB,SAASoB,OAAOrB,oCAMrBL,cAEG2B,QAAQxB,KAAKQ,QAAQX,IAC5B,MAAO4B,UACA,+BAGP5B,WAEME,EAAOC,KAAKQ,QAAQX,UACnB2B,QAAQzB,GAAQA,EAAKuB,eAAe,UAC3C,MAAOG,UACA"}